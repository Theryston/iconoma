import { LockFileIcon } from "../types";
import {
  getConfig,
  getIconContent,
  getPwd,
  keyToComponentName,
} from "../utils";
import { TargetClient } from "./interface";
import { transform } from "@svgr/core";
import fs from "node:fs/promises";
import path from "node:path";

type SplitResult = {
  imports: string[];
  exports: string[];
  content: string;
};

function splitSvgrComponentSource(source: string): SplitResult {
  const lines = String(source).replace(/\r\n?/g, "\n").split("\n");

  const imports: string[] = [];
  const exports: string[] = [];
  const bodyLines: string[] = [];

  const isImportStart = (line: string) => /^\s*import\b/.test(line);
  const isExportStart = (line: string) => /^\s*export\b/.test(line);

  const isImportEnd = (blockText: string) => {
    const t = blockText.trim();
    if (/^\s*import\s*["'][^"']+["']\s*;?\s*$/.test(t)) return true;
    if (/\bfrom\s*["'][^"']+["']\s*;?\s*$/.test(t)) return true;
    return false;
  };

  const isExportEnd = (blockText: string) => {
    const t = blockText.trim();
    if (/;\s*$/.test(t)) return true;
    if (/^\s*export\s+default\b/.test(t)) return true;
    if (/^\s*export\s*{\s*[\s\S]*}\s*;?\s*$/.test(t)) return true;
    return false;
  };

  let mode: "import" | "export" | null = null;
  let acc: string[] = [];

  const flush = () => {
    if (!mode) return;
    const block = acc.join("\n").trim();
    if (block) {
      if (mode === "import") imports.push(block);
      if (mode === "export") exports.push(block);
    }
    mode = null;
    acc = [];
  };

  for (const line of lines) {
    if (!mode && isImportStart(line)) {
      mode = "import";
      acc.push(line);
      if (isImportEnd(acc.join("\n"))) flush();
      continue;
    }

    if (!mode && isExportStart(line)) {
      mode = "export";
      acc.push(line);
      if (isExportEnd(acc.join("\n"))) flush();
      continue;
    }

    if (mode === "import") {
      acc.push(line);
      if (isImportEnd(acc.join("\n"))) flush();
      continue;
    }

    if (mode === "export") {
      acc.push(line);
      if (isExportEnd(acc.join("\n"))) flush();
      continue;
    }

    bodyLines.push(line);
  }

  flush();

  const body = bodyLines.join("\n");
  const startMatch = body.match(/(^|\n)\s*(const|function)\s+\w+/);
  let content = body.trim();

  if (startMatch) {
    const startIdx = body.indexOf(startMatch[0]) + (startMatch[1] ? 1 : 0);
    content = body.slice(startIdx).trim();
  }

  return { imports, exports, content };
}

function getDefaultExportName(exports: string[]): string | null {
  for (const e of exports) {
    const m = e.match(/export\s+default\s+([A-Za-z_$][\w$]*)/);
    if (m?.[1]) return m[1];
  }
  return null;
}

function toNamedExport(componentCode: string, name: string): string {
  const constRe = new RegExp(`^\\s*const\\s+${name}\\b`);
  if (constRe.test(componentCode)) {
    return componentCode.replace(constRe, `export const ${name}`);
  }

  const fnRe = new RegExp(`^\\s*function\\s+${name}\\b`);
  if (fnRe.test(componentCode)) {
    return componentCode.replace(fnRe, `export function ${name}`);
  }

  return `export ${componentCode.trimStart()}`;
}

function uniqStable(items: string[]): string[] {
  const seen = new Set<string>();
  const out: string[] = [];
  for (const it of items) {
    const key = it.trim();
    if (!key) continue;
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(it.trim());
  }
  return out;
}

function extractTopImports(fileText: string): {
  imports: string[];
  rest: string;
} {
  const lines = fileText.replace(/\r\n?/g, "\n").split("\n");

  const imports: string[] = [];
  let i = 0;

  while (i < lines.length && /^\s*\/\/.*/.test(lines[i] ?? "")) i++;
  while (i < lines.length && /^\s*$/.test(lines[i] ?? "")) i++;

  while (i < lines.length) {
    const line = lines[i];
    if (!/^\s*import\b/.test(line ?? "")) break;

    const block: string[] = [line ?? ""];
    i++;

    while (i < lines.length) {
      const t = block.join("\n").trim();
      if (
        /^\s*import\s*["'][^"']+["']\s*;?\s*$/.test(t) ||
        /\bfrom\s*["'][^"']+["']\s*;?\s*$/.test(t)
      ) {
        break;
      }
      block.push(lines[i] ?? "");
      i++;
    }

    imports.push(block.join("\n").trim());
    i++;
    while (i < lines.length && /^\s*$/.test(lines[i] ?? "")) i++;
  }

  const rest = lines.slice(i).join("\n").replace(/^\n+/, "");
  return { imports, rest };
}

function ensureHeader(fileText: string): string {
  const header =
    `// DON'T EDIT THIS FILE RUN \`npx @iconoma/cli studio\` TO UPDATE IT.\n` +
    `// IT IS GENERATED BY ICONOMA.\n`;

  const trimmed = fileText.trimStart();
  if (trimmed.startsWith("// DON'T EDIT THIS FILE")) return fileText;
  return header + fileText.replace(/^\n+/, "");
}

function buildIconBlock(
  iconKey: string,
  componentName: string,
  namedExportCode: string
): string {
  return (
    `// <iconoma-icon key="${iconKey}" name="${componentName}">\n` +
    `${namedExportCode.trim()}\n` +
    `// </iconoma-icon>\n`
  );
}

function upsertIconBlock(
  fileRest: string,
  iconKey: string,
  componentName: string,
  block: string
): string {
  const esc = (s: string) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const pattern = new RegExp(
    `//\\s*<iconoma-icon\\s+key="${esc(iconKey)}"\\s+name="${esc(componentName)}">[\\s\\S]*?//\\s*</iconoma-icon>\\s*\\n?`,
    "m"
  );

  if (pattern.test(fileRest)) {
    return fileRest.replace(pattern, block + "\n");
  }

  const restTrimmed = fileRest.trim();
  if (!restTrimmed) return block + "\n";
  return restTrimmed + "\n\n" + block + "\n";
}

function hasAnyIconBlocks(fileText: string): boolean {
  return /\/\/\s*<iconoma-icon\b/.test(fileText);
}

function removeIconBlockFromFile(
  fileText: string,
  iconKey: string
): {
  next: string;
  removed: boolean;
} {
  const esc = (s: string) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const key = esc(iconKey);

  const pattern = new RegExp(
    `(^|\\n)\\s*//\\s*<iconoma-icon\\s+key="${key}"\\s+name="[^"]*">\\s*\\n[\\s\\S]*?\\n\\s*//\\s*</iconoma-icon>\\s*(\\n|$)`,
    "m"
  );

  if (!pattern.test(fileText)) {
    return { next: fileText, removed: false };
  }

  const next = fileText
    .replace(pattern, "\n")
    .replace(/\n{3,}/g, "\n\n")
    .trimEnd()
    .concat("\n");

  return { next, removed: true };
}

export class ReactTargetClient implements TargetClient {
  async addIcon(
    icon: LockFileIcon,
    iconKey: string,
    filePath: string
  ): Promise<void> {
    const content = await getIconContent(icon);

    const componentName = keyToComponentName(iconKey);

    const config = await getConfig();

    const reactContent = await transform(
      content,
      {
        plugins: [
          "@svgr/plugin-svgo",
          "@svgr/plugin-jsx",
          "@svgr/plugin-prettier",
        ],
        icon: true,
        svgoConfig: config?.svgo,
        typescript: filePath.endsWith(".tsx"),
      },
      { componentName }
    );

    await this.writeComponent(iconKey, reactContent, filePath);
  }

  async removeIcon(
    icon: LockFileIcon,
    iconKey: string,
    filePath: string
  ): Promise<void> {
    const pwd = await getPwd();
    const fullPath = path.join(pwd, filePath);

    const isUniqueFile =
      fullPath.endsWith(`${iconKey}.tsx`) ||
      fullPath.endsWith(`${iconKey}.jsx`);

    if (isUniqueFile) {
      await this.deleteFile(fullPath);
      return;
    }

    const fileExists = await fs
      .access(fullPath)
      .then(() => true)
      .catch(() => false);

    if (!fileExists) return;

    const existing = await fs.readFile(fullPath, "utf-8");

    const { next, removed } = removeIconBlockFromFile(existing, iconKey);

    if (!removed) return;

    if (!hasAnyIconBlocks(next)) {
      await this.deleteFile(fullPath);
      return;
    }

    await fs.writeFile(fullPath, next);
  }

  async deleteFile(fullPath: string): Promise<void> {
    const exists = await fs
      .access(fullPath)
      .then(() => true)
      .catch(() => false);

    if (!exists) return;

    await fs.unlink(fullPath);
    const folder = path.dirname(fullPath);
    const files = await fs.readdir(folder);

    if (files.length === 0) {
      await fs.rmdir(folder);
    }
  }

  async writeComponent(
    iconKey: string,
    content: string,
    filePath: string
  ): Promise<void> {
    const pwd = await getPwd();
    const fullPath = path.join(pwd, filePath);
    const folder = path.dirname(fullPath);
    await fs.mkdir(folder, { recursive: true });

    const isUniqueFile =
      fullPath.endsWith(`${iconKey}.tsx`) ||
      fullPath.endsWith(`${iconKey}.jsx`);

    if (isUniqueFile) {
      await fs.writeFile(
        fullPath,
        `// DON'T EDIT THIS FILE RUN \`npx @iconoma/cli studio\` TO UPDATE IT.\n// IT IS GENERATED BY ICONOMA.\n${content}\n`
      );
      return;
    }

    const componentName = keyToComponentName(iconKey);
    const parsed = splitSvgrComponentSource(content);

    const defaultName = getDefaultExportName(parsed.exports) ?? componentName;
    const namedExportCode = toNamedExport(parsed.content, defaultName);

    const newBlock = buildIconBlock(iconKey, componentName, namedExportCode);

    const fileExists = await fs
      .access(fullPath)
      .then(() => true)
      .catch(() => false);

    if (!fileExists) {
      const imports = uniqStable(parsed.imports);
      const initial =
        ensureHeader("") +
        (imports.length ? imports.join("\n") + "\n\n" : "") +
        newBlock +
        "\n";

      await fs.writeFile(fullPath, initial);
      return;
    }

    const existing = await fs.readFile(fullPath, "utf-8");
    const existingWithHeader = ensureHeader(existing);

    const { imports: existingImports, rest } =
      extractTopImports(existingWithHeader);

    const mergedImports = uniqStable([...existingImports, ...parsed.imports]);

    const updatedRest = upsertIconBlock(rest, iconKey, componentName, newBlock);

    const finalText =
      ensureHeader("") +
      (mergedImports.length ? mergedImports.join("\n") + "\n\n" : "") +
      updatedRest.trim() +
      "\n";

    await fs.writeFile(fullPath, finalText);
  }
}
